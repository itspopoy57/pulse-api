generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PostType {
  HOT_TAKE
  CONFESSION
  QUESTION
  VS
  POLL
}

enum ReactionType {
  UPVOTE
  DOWNVOTE
}

enum VsSide {
  A
  B
}

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  passwordHash String
  username     String?  @unique
  region       String?
  createdAt    DateTime @default(now())

  // admin
  isAdmin      Boolean  @default(false)
  isBanned     Boolean  @default(false)
  bannedAt     DateTime?
  bannedReason String?

  // profile
  displayName  String?
  bio          String?
  avatarUrl    String?

  // preferences
  theme        String?  @default("dark") // 'dark' or 'light'

  // push notifications
  pushToken    String?
  pushPlatform String?  // 'ios' or 'android'
  notificationsEnabled Boolean @default(true)
  
  // notification preferences
  notifyMessages   Boolean @default(true)
  notifyConnections Boolean @default(true)
  notifyComments   Boolean @default(true)
  notifyReactions  Boolean @default(true)
  notifyMentions   Boolean @default(true)

  posts        Post[]
  comments     Comment[]

  // reactions
  postReactions    PostReaction[]
  vsVotes          VsVote[]
  commentReactions CommentReaction[]

  // bookmarks
  savedPosts   SavedPost[]

  // connection system (like LinkedIn)
  sentConnections     Connection[] @relation("ConnectionRequester")
  receivedConnections Connection[] @relation("ConnectionReceiver")
  
  // poll votes
  pollVotes    PollVote[]
  
  // messaging
  sentMessages     Message[] @relation("MessageSender")
  receivedMessages Message[] @relation("MessageReceiver")
  conversations1   Conversation[] @relation("ConversationUser1")
  conversations2   Conversation[] @relation("ConversationUser2")
  messageReactions MessageReaction[]
  
  // group messaging
  groupMemberships GroupMember[]
  groupMessages    GroupMessage[]
  createdGroups    Group[] @relation("GroupCreator")
  groupMessageReads GroupMessageRead[]
  typingInGroups   GroupTyping[]
  
  // notifications
  notifications    Notification[]
  
  // blocking
  blockedUsers     BlockedUser[] @relation("BlockerUser")
  blockedByUsers   BlockedUser[] @relation("BlockedUser")
}

model Poll {
  id            Int          @id @default(autoincrement())
  postId        Int          @unique
  post          Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  // Poll settings
  allowMultiple Boolean      @default(false)
  maxChoices    Int?
  endsAt        DateTime?
  
  // Metadata
  totalVotes    Int          @default(0)
  options       PollOption[]
  votes         PollVote[]
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  
  @@index([postId])
}

model PollOption {
  id        Int        @id @default(autoincrement())
  pollId    Int
  poll      Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  
  text      String     @db.VarChar(100)
  order     Int
  votes     PollVote[]
  voteCount Int        @default(0)
  
  createdAt DateTime   @default(now())
  
  @@index([pollId])
  @@index([pollId, order])
}

model PollVote {
  id        Int        @id @default(autoincrement())
  pollId    Int
  poll      Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  optionId  Int
  option    PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  userId    Int
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime   @default(now())
  
  @@unique([userId, pollId, optionId])
  @@index([pollId])
  @@index([optionId])
  @@index([userId])
}

model Post {
  id            Int        @id @default(autoincrement())
  type          PostType
  title         String
  body          String?

  // media on posts
  mediaUrl      String?
  mediaType     String?

  sideA         String?
  sideB         String?
  votesA        Int        @default(0)
  votesB        Int        @default(0)
  upvotes       Int        @default(0)
  downvotes     Int        @default(0)
  isAnonymous   Boolean    @default(true)
  region        String?

  // moderation
  isReported    Boolean    @default(false)
  isHidden      Boolean    @default(false)
  reportedCount Int        @default(0)
  moderatedAt   DateTime?
  moderatedBy   Int?
  moderationNote String?

  author        User       @relation(fields: [authorId], references: [id])
  authorId      Int

  comments      Comment[]
  reactions     PostReaction[]
  vsVotes       VsVote[]
  poll          Poll?

  // who bookmarked this
  savedBy       SavedPost[]
  
  // hashtags
  hashtags      PostHashtag[]

  createdAt     DateTime   @default(now())
  
  @@index([createdAt])
}

model Comment {
  id            Int       @id @default(autoincrement())
  text          String
  isAnonymous   Boolean   @default(true)
  likeCount     Int       @default(0)
  isHidden      Boolean   @default(false)
  reportedCount Int       @default(0)
  isReported    Boolean   @default(false)
  moderatedAt   DateTime?
  moderatedBy   Int?
  moderationNote String?

  mediaUrl      String?
  mediaType     String?

  postId   Int
  post     Post   @relation(fields: [postId], references: [id])

  authorId Int
  author   User   @relation(fields: [authorId], references: [id])

  parentId Int?
  parent   Comment?  @relation("CommentToComment", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentToComment")

  reactions CommentReaction[]

  createdAt DateTime @default(now())
}

// one reaction per user per post
model PostReaction {
  id        Int          @id @default(autoincrement())
  type      ReactionType

  user      User         @relation(fields: [userId], references: [id])
  userId    Int

  post      Post         @relation(fields: [postId], references: [id])
  postId    Int

  @@unique([userId, postId])
}

// one VS vote per user per post
model VsVote {
  id     Int    @id @default(autoincrement())
  side   VsSide

  user   User   @relation(fields: [userId], references: [id])
  userId Int

  post   Post   @relation(fields: [postId], references: [id])
  postId Int

  @@unique([userId, postId])
}

// Enhanced comment reactions with emoji types
enum EmojiReactionType {
  LIKE      // üëç
  LOVE      // ‚ù§Ô∏è
  FIRE      // üî•
  LAUGH     // üòÇ
  WOW       // üòÆ
  SAD       // üò¢
  ANGRY     // üò†
}

model CommentReaction {
  id        Int                @id @default(autoincrement())
  type      ReactionType?      // Keep for backward compatibility
  emoji     EmojiReactionType? // New emoji reactions

  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int

  comment   Comment            @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId Int
  
  createdAt DateTime           @default(now())

  @@unique([userId, commentId])
  @@index([commentId])
}

// saved posts (bookmarks)
model SavedPost {
  id        Int      @id @default(autoincrement())
  userId    Int
  postId    Int

  user      User     @relation(fields: [userId], references: [id])
  post      Post     @relation(fields: [postId], references: [id])

  createdAt DateTime @default(now())

  @@unique([userId, postId])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Connection {
  id          Int              @id @default(autoincrement())

  // who sent the connection request
  requester   User             @relation("ConnectionRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  requesterId Int

  // who received the connection request
  receiver    User             @relation("ConnectionReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  Int

  status      ConnectionStatus @default(PENDING)
  
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  acceptedAt  DateTime?

  @@unique([requesterId, receiverId])
  @@index([requesterId])
  @@index([receiverId])
  @@index([status])
}

// Conversations between two users
model Conversation {
  id            Int       @id @default(autoincrement())
  
  // The two participants
  user1         User      @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user1Id       Int
  
  user2         User      @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  user2Id       Int
  
  // Messages in this conversation
  messages      Message[]
  
  // Last message info for sorting
  lastMessageAt DateTime  @default(now())
  lastMessageText String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([lastMessageAt])
}

// Individual messages
model Message {
  id             Int          @id @default(autoincrement())
  
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId Int
  
  sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId       Int
  
  receiver       User         @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId     Int
  
  text           String?      @db.Text
  
  // Attachments (images, files)
  mediaUrl       String?
  mediaType      String?      // 'image' or 'file'
  fileName       String?      // Original filename for files
  
  // Message status
  isRead         Boolean      @default(false)
  readAt         DateTime?
  
  // Soft delete for admin monitoring
  isDeleted      Boolean      @default(false)
  deletedAt      DateTime?
  deletedBy      Int?
  
  createdAt      DateTime     @default(now())
  
  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@index([isDeleted])
  
  // message reactions
  reactions MessageReaction[]
}

// Message reactions
model MessageReaction {
  id        Int                @id @default(autoincrement())
  
  message   Message            @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId Int
  
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int
  
  emoji     String             // Emoji character (e.g., "üëç", "‚ù§Ô∏è", "üòÇ")
  
  createdAt DateTime           @default(now())
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
}

// In-app notifications
model Notification {
  id        Int      @id @default(autoincrement())
  
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type      String   // 'message', 'follow', 'comment', 'reaction', 'mention', 'group_message', 'group_invite'
  title     String
  body      String
  
  // Related entities
  fromUserId   Int?
  postId       Int?
  commentId    Int?
  conversationId Int?
  groupId      Int?
  
  // Status
  isRead    Boolean  @default(false)
  readAt    DateTime?
  
  // Data for navigation
  data      Json?
  
  createdAt DateTime @default(now())
  
  @@index([userId])
  @@index([userId, isRead])
  @@index([createdAt])
}

// Group chat models
model Group {
  id          Int      @id @default(autoincrement())
  name        String   @db.VarChar(100)
  description String?  @db.Text
  avatarUrl   String?
  
  // Creator/owner
  creatorId   Int
  creator     User     @relation("GroupCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  
  // Members
  members     GroupMember[]
  messages    GroupMessage[]
  
  // Typing indicators
  typingUsers GroupTyping[]
  
  // Metadata
  lastMessageAt DateTime?
  lastMessageText String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([creatorId])
  @@index([lastMessageAt])
}

enum GroupRole {
  ADMIN
  MEMBER
}

model GroupMember {
  id        Int       @id @default(autoincrement())
  
  groupId   Int
  group     Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  role      GroupRole @default(MEMBER)
  
  // Notification settings per group
  isMuted   Boolean   @default(false)
  
  joinedAt  DateTime  @default(now())
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model GroupMessage {
  id        Int      @id @default(autoincrement())
  
  groupId   Int
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  senderId  Int
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  text      String?  @db.Text
  
  // Attachments
  mediaUrl  String?
  mediaType String?  // 'image' or 'file'
  fileName  String?
  
  // Read receipts
  reads     GroupMessageRead[]
  
  // Soft delete
  isDeleted Boolean  @default(false)
  deletedAt DateTime?
  deletedBy Int?
  
  createdAt DateTime @default(now())
  
  @@index([groupId])
  @@index([senderId])
  @@index([createdAt])
  @@index([groupId, createdAt])
}

// Track who has read each message
model GroupMessageRead {
  id        Int      @id @default(autoincrement())
  
  messageId Int
  message   GroupMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  readAt    DateTime @default(now())
  
  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
}

// Typing indicators for groups
model GroupTyping {
  id        Int      @id @default(autoincrement())
  
  groupId   Int
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  updatedAt DateTime @updatedAt
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([updatedAt])
}

// Hashtags
model Hashtag {
  id        Int           @id @default(autoincrement())
  tag       String        @unique // lowercase, no # symbol
  
  posts     PostHashtag[]
  
  // Metadata
  useCount  Int           @default(0)
  
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  
  @@index([tag])
  @@index([useCount])
}

// Many-to-many relationship between posts and hashtags
model PostHashtag {
  id        Int      @id @default(autoincrement())
  
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    Int
  
  hashtag   Hashtag  @relation(fields: [hashtagId], references: [id], onDelete: Cascade)
  hashtagId Int
  
  createdAt DateTime @default(now())
  
  @@unique([postId, hashtagId])
  @@index([postId])
  @@index([hashtagId])
}

// Blocked users
model BlockedUser {
  id        Int      @id @default(autoincrement())
  
  // who is doing the blocking
  blocker   User     @relation("BlockerUser", fields: [blockerId], references: [id], onDelete: Cascade)
  blockerId Int
  
  // who is being blocked
  blocked   User     @relation("BlockedUser", fields: [blockedId], references: [id], onDelete: Cascade)
  blockedId Int
  
  reason    String?  // Optional reason for blocking
  
  createdAt DateTime @default(now())
  
  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}
